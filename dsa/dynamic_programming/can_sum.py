"""
Write a functon can_sum that takes in a target sum and 
an array of numbers as its arguments. 

The function should return a boolean value depending on if 
the target can be generated by the numbers in the array.

You may use the elements in the array as many times as needed.
You may assume that all input numbers are non-negative.
"""

def can_sum(target, numbers):
    """
    n = len(numbers)
    m = target
    Can_sum without memoization. Has a time complexity of O(n^m)
    time complexity. O(m) space.
    """

    if target == 0:
        return True
    if target < 0:
        return False
    for num in numbers:
        diff = target - num
        if can_sum(diff, numbers):
            return True

    return False


def can_sum_memo(target, numbers, memo=dict()):
    """
    Memoized can_sum. Time complexity of O(m * n). O(m) space.
    """

    if target in memo:
        return memo[target]
    if target == 0:
        return True
    if target < 0:
        return False
    for num in numbers:
        diff = target - num
        if can_sum(diff, numbers):
            memo[target] = True
            return True

    return False

def can_sum_tab(target, numbers):
    """
    Tabulated can_sum. Time complexity of O(m * n). O(m) space.
    """
    table = [False] * (target + 1)
    table[0] = True

    # for number in numbers:
    #     if number <= target:
    #         table[number] = True
    
    for index in range(target+1):
        if table[index]:
            for number in numbers:
                if index+number < target+1:
                    table[index+number] = True
    
    return table[target]

    
    


